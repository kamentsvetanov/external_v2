function setnodes(nr_nu,nr_z)
%SETNODES  Set the number of quadrature nodes used by DMAT
%   SETNODES(NR_NU,NR_Z) sets the number of quadrature nodes for the drift
%   rate integral (Gauss-Hermite nodes) to NR_NU, and the number of nodes
%   for the starting point integral (Gauss-Legendre nodes) to NR_Z. A .C
%   file (CDFDIF.C) is created and compiled to a binary file, with the
%   quadrature points hard-coded into the function.
%   If no input arguments are given, the default values 10 and 10 are used,
%   if only one input argument is given, NR_NU = NR_Z.
%
%   The maximum number of Gauss-Legendre nodes (NR_Z) is 40.
%
%   The number of Gauss-Hermite nodes (NR_NU) must an be even number.
%
%   For small datasets, the number of quadrature points may not have a
%   significant effect. Using low numbers (e.g., 6 for both) will then
%   yield faster convergence.
%
%   SETNODES requires use of a MEX-compiler (so it will execute 'mex
%   -setup' if necessary). This functionality has only been tested on a
%   Windows XP platform with the LCC C compiler.
%
%   SETNODES is more efficient if the Symbolic Toolbox is available.
%
%   Note that the compiled files that are included in the installation
%   package (containing 10 nodes for each integral) are generated with the
%   Symbolic Math Toolbox installed. If you do not have this Toolbox and
%   overwrite the compiled file, the computation of the CDF will be less
%   precise. However, uncompiled back-up files for 10 nodes or 30 nodes for
%   each integral are also included in the installation package (CDFDIF10.C
%   and CDFDIF30.C).
%
%   See also CDFDIF.
%
%   Author: Joachim Vandekerckhove (joachim.vandekerckhove@psy.kuleuven.be)
%   Part of the DMA Toolbox. Please read the End User License Agreement,
%   contained in 'dmateula.txt' or by invoking the DMATLICENSE command. 
%   See also http://ppw.kuleuven.be/okp/dmatoolbox.

%  Edit 0.4: Fixed so CDFDIF.C doesn't overwrite zero-valued parameters
%  in-place anymore.

%% Check input
if nargin==1
    nr_z = nr_nu;
elseif ~nargin
    nr_nu = 10;
    nr_z = 10;
end

if nr_z>40
    error('The maximum number of Gauss-Legendre nodes is 40.');
end
if nr_nu>170
    error('The maximum number of Gauss-Hermite nodes is 170.');
end
if nr_nu>50
    warning('DMAT:setnodes:SoManyNodes',...
        ['A large number of Gauss-Hermite nodes will significantly\n'...
        '         increase processing time with little or no gain in accuracy.']);
end
if mod(nr_nu,2)
    error('The number of Gauss-Hermite nodes must be even.')
end

dmatdir = getpref('dmatoolbox','dmatdir');

%% Check for default numbers
deffile = (nr_nu==10 && nr_z==10) || (nr_nu==30 && nr_z==30);
if deffile
    filename = sprintf('cdfdif%i',nr_z);
    fullname = fullfile(dmatdir,[filename '.c']);
    fprintf('Using included file %s...\n',[filename '.c'])
else
    filename = 'cdfdif';
    fullname = fullfile(dmatdir,[filename '.c']);
    fprintf('Dynamically creating file %s...\n',[filename '.c'])
    file = makecfile(nr_nu,nr_z);
    %Write the .c file
    fid = fopen(fullname,'w');
    fprintf(fid,file);
    fclose(fid);
end

n = pwd;
cd(dmatdir)

%% Now, compile it (MEX handles -setup by itself)
mex(fullname);

%% If necessary, rename binary
if deffile
    normalmexfilename = fullfile(dmatdir,['cdfdif.' mexext]);
    thismexfilename = fullfile(dmatdir,[filename '.' mexext]);
    if exist(normalmexfilename,'file')
        delete(normalmexfilename);
    end
    copyfile(thismexfilename,normalmexfilename)
    delete(thismexfilename)
end

%% Report success
cd(n)
fprintf(['File cdfdif.%s written.\nGauss-Hermite quadrature points: %3i\n'...
    'Gauss-Legendre quadrature points:%3i\n'],mexext,nr_nu,nr_z);
setpref('dmatoolbox','nodes',[nr_nu nr_z]);


%% %%
%% Subfunctions
function file = makecfile(nr_nu,nr_z)
%% Gauss-Hermite nodes
try
    g = vpa(ghnodes(nr_nu),20);
    gkstr = char(g(:,1));
    gkstr = gkstr(9:end-2);
    gkstr = strrep(gkstr, '[', '');
    gkstr = strrep(gkstr, ']', '');
    w_ghstr = char(g(:,2));
    w_ghstr = w_ghstr(9:end-2);
    w_ghstr = strrep(w_ghstr, '[', '');
    w_ghstr = strrep(w_ghstr, ']', '');
catch
    warning('DMAT:setnodes:SymbolicToolboxNotFound',...
        'Symbolic Math Toolbox not found. DMAT may work at lower precision.')
    g = ghnodes(nr_nu);
    gkstr = sprintf('%20.17f,',g(:,1));
    w_ghstr = sprintf('%20.17f,',g(:,2));
    gkstr(end)='';
    w_ghstr(end)='';
end

%% Gauss-Legendre nodes
try
    g = vpa(glnodes(nr_z),20);
    gzstr = char(g(:,1));
    gzstr = gzstr(9:end-2);
    gzstr = strrep(gzstr, '[', '');
    gzstr = strrep(gzstr, ']', '');
    w_gstr = char(g(:,2));
    w_gstr = w_gstr(9:end-2);
    w_gstr = strrep(w_gstr, '[', '');
    w_gstr = strrep(w_gstr, ']', '');
catch
    g = glnodes(nr_z);
    gzstr = sprintf('%20.17f,',g(:,1));
    w_gstr = sprintf('%20.17f,',g(:,2));
    gzstr(end)='';
    w_gstr(end)='';
end

%% Prepare the .c file
file = sprintf(['/*\n'...
'  Name: cdfdif.c\n'...
'  Copyright: Academic use\n'...
'  Author: Joachim Vandekerckhove\n'...
'          Department of Psychology\n'...
'          Katholieke Universiteit Leuven\n'...
'          Belgium\n'...
'          email: joachim.vandekerckhove@psy.kuleuven.be\n'...
'  Date: The generating algorithm was written on 09/01/06\n'...
'  Description: Computes Cumulative Distribution Function for the Diffusion\n'...
'               model with random trial to trial mean drift (normal), starting\n'...
'               point and non-decision (ter) time (both rectangular).\n'...
'               Uses %i quadrature points for drift and %i for the others.\n'...
'               Based on methods described in:\n'...
'                     Tuerlinckx, F. (2004). The efficient computation of the\n'...
'                     cumulative distribution and probability density functions\n'...
'                     in the diffusion model, Behavior Research Methods,\n'...
'                     Instruments, & Computers, 36 (4), 702-716.\n'...
' \n'...
' */\n'...
'\n'...
'#include <stdlib.h>\n'...
'#include <math.h>\n'...
'#include <mex.h>\n'...
'#include <matrix.h>\n'...
'#include <tmwtypes.h>\n'...
'\n'...
'#define PI 3.1415926535897932384626433832795028841971693993751\n'...
'\n'...
'\n'...
'double cdfdif(double t, int x, double *par, double *prob);\n'...
'void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);\n'...
'double absol(double a){ return a>0 ? a : -a; }\n'...
'\n'...
'void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] )\n'...
'{\n'...
'    double *p, *nwp, *x, *t, *y, *pr, nonzero = 1e-10;\n'...
'    int nt,i;\n'...
'    \n'...
'    t = mxGetPr(prhs[0]);\n'...
'    x = mxGetPr(prhs[1]);\n'...
'    p = mxGetPr(prhs[2]);\n'...
'    nt = mxGetN(prhs[0]);\n'...
'    \n'...
'    nwp = malloc(7*sizeof(double));\n'...
'    for(i=0;i<7;i++) nwp[i]=p[i];\n'...
'    \n'...
'    plhs[0] = mxCreateDoubleMatrix(1,nt, mxREAL);\n'...
'    plhs[1] = mxCreateDoubleMatrix(1,1, mxREAL);\n'...
'    y = mxGetPr(plhs[0]);\n'...
'    pr = mxGetPr(plhs[1]);\n'...
'    \n'...
'    if (nwp[2]<nonzero) { nwp[2] = nonzero; }\n'...
'    if (nwp[4]<nonzero) { nwp[4] = nonzero; }\n'...
'    if (nwp[5]<nonzero) { nwp[5] = nonzero; }\n'...
'    for (i=0;i<nt;i++) y[i] = cdfdif(t[i],*x,nwp,pr);\n'...
'}\n'...
'\n'...
'/* The main function for the seven-parameter diffusion model */\n'...
'double cdfdif(double t, int x, double *par, double *prob)\n'...
'{\n'...
'    double a = par[0], Ter = par[1], eta = par[2], z = par[3], sZ = par[4],\n'...
'    st = par[5], nu = par[6], a2 = a*a,\n'...
'    Z_U = (1-x)*z+x*(a-z)+sZ/2, /* upper boundary of z distribution */\n'...
'    Z_L = (1-x)*z+x*(a-z)-sZ/2, /* lower boundary of z distribution */\n'...
'    lower_t = Ter-st/2, /* lower boundary of Ter distribution */\n'...
'    upper_t, /* upper boundary of Ter distribution */\n'...
'    delta = 1e-29, /* convergence values for terms added to partial sum */\n'...
'    epsilon = 1e-7, /* value to check deviation from zero */\n'...
'    min_RT=0.001; /* realistic minimum rt to complete decision process */\n'...
'    \n'...
'    int v_max = 5000; /* maximum number of terms in a partial sum */\n'...
'    /* approximating infinite series */\n'...
'    \n'...
'    double Fnew, sum_z=0, sum_nu=0, p1, p0, sum_hist[3]={0,0,0},\n'...
'    denom, sifa, upp, low, fact, exdif, su, sl, zzz, ser;\n'...
'    double nr_nu = %i, nr_z = %i;\n'...
'    \n'...
'    double gk[%i]={%s},\n'...
'           w_gh[%i]={%s},\n'...
'           gz[%i]={%s},\n'...
'           w_g[%i]={%s};\n'...
'    int i,m,v;\n'...
'    \n'...
'    for(i=0; i<nr_nu; i++)\n'...
'    {\n'...
'        gk[i] = 1.41421356237309505*gk[i]*eta+nu;\n'...
'        /* appropriate scaling of GH quadrature nodes based on normal kernel */\n'...
'        w_gh[i] = w_gh[i]/1.772453850905515882;\n'...
'        /* appropriate weighting of GH quadrature weights based on normal kernel */\n'...
'    }\n'...
'    for(i=0; i<nr_z; i++)\n'...
'        gz[i] = (.5*sZ*gz[i])+z;\n'...
'    /* appropriate scaling of Gaussian quadrature nodes */\n'...
'    \n'...
'    /* numerical integration with respect to z_0 */\n'...
'    for (i=0; i<nr_z; i++)\n'...
'    {\n'...
'        sum_nu=0;\n'...
'        /* numerical integration with respect to xi */\n'...
'        for (m=0; m<nr_nu; m++)\n'...
'        {\n'...
'            if (absol(gk[m])>epsilon) /* test for gk(m) being close to zero */\n'...
'            {\n'...
'                sum_nu+=(exp(-200*gz[i]*gk[m])-1)/(exp(-200*a*gk[m])-1)*w_gh[m];\n'...
'            }\n'...
'            else\n'...
'            {\n'...
'                sum_nu+=gz[i]/a*w_gh[m];\n'...
'            }\n'...
'        }\n'...
'        sum_z+=sum_nu*w_g[i]/2;\n'...
'    }\n'...
'    *prob=sum_z;\n'...
'    /* end of prob */\n'...
'    \n'...
'    if (t-Ter+st/2>min_RT)/* is t larger than lower boundary Ter distribution? */\n'...
'    {\n'...
'        upper_t = t<Ter+st/2 ? t : Ter+st/2;\n'...
'        p1=*prob*(upper_t-lower_t)/st; /* integrate probability with respect to t */\n'...
'        p0=(1-*prob)*(upper_t-lower_t)/st;\n'...
'        if (t>Ter+st/2) /* is t larger than upper boundary Ter distribution? */\n'...
'        {\n'...
'            sum_hist[0] = 0;\n'...
'            sum_hist[1] = 0;\n'...
'            sum_hist[2] = 0;\n'...
'            for (v=0;v<v_max;v++) /* infinite series */\n'...
'            {\n'...
'                sum_hist[0]=sum_hist[1];\n'...
'                sum_hist[1]=sum_hist[2];\n'...
'                sum_nu=0;\n'...
'                sifa=PI*v/a;\n'...
'                for (m=0;m<nr_nu;m++) /* numerical integration with respect to xi */\n'...
'                {\n'...
'                    denom=(100*gk[m]*gk[m]+(PI*PI)*(v*v)/(100*a2));\n'...
'                    upp=exp((2*x-1)*Z_U*gk[m]*100-3*log(denom)+log(w_gh[m])-2*log(100));\n'...
'                    low=exp((2*x-1)*Z_L*gk[m]*100-3*log(denom)+log(w_gh[m])-2*log(100));\n'...
'                    fact=upp*((2*x-1)*gk[m]*sin(sifa*Z_U)*100-sifa*cos(sifa*Z_U))-\n'...
'                    low*((2*x-1)*gk[m]*sin(sifa*Z_L)*100-sifa*cos(sifa*Z_L));\n'...
'                    exdif=exp((-.5*denom*(t-upper_t))+\n'...
'                    log(1-exp(-.5*denom*(upper_t-lower_t))));\n'...
'                    sum_nu+=fact*exdif;\n'...
'                }\n'...
'                sum_hist[2]=sum_hist[1]+v*sum_nu;\n'...
'                if ((absol(sum_hist[0]-sum_hist[1])<delta) &&\n'...
'                (absol(sum_hist[1]-sum_hist[2])<delta) && (sum_hist[2]>0))\n'...
'                    break;\n'...
'            }\n'...
'            Fnew=(p0*(1-x)+p1*x)-sum_hist[2]*4*PI/(a2*sZ*st);\n'...
'            /* cumulative distribution function for t and x */\n'...
'        }\n'...
'        else if (t<=Ter+st/2) /* is t lower than upper boundary Ter distribution? */\n'...
'        {\n'...
'            sum_nu=0;\n'...
'            for (m=0;m<nr_nu;m++)\n'...
'            {\n'...
'                if (absol(gk[m])>epsilon)\n'...
'                {\n'...
'                    sum_z=0;\n'...
'                    for (i=0;i<nr_z;i++)\n'...
'                    {\n'...
'                        zzz=(a-gz[i])*x+gz[i]*(1-x);\n'...
'                        ser=-((a*a2)/((1-2*x)*gk[m]*PI*.01))*sinh(zzz*(1-2*x)*gk[m]/.01)/\n'...
'                        (sinh((1-2*x)*gk[m]*a/.01)*sinh((1-2*x)*gk[m]*a/.01))\n'...
'                        +(zzz*a2)/((1-2*x)*gk[m]*PI*.01)*cosh((a-zzz)*(1-2*x)\n'...
'                        *gk[m]/.01)/sinh((1-2*x)*gk[m]*a/.01);\n'...
'                        sum_hist[0] = 0;\n'...
'                        sum_hist[1] = 0;\n'...
'                        sum_hist[2] = 0;\n'...
'                        for (v=0;v<v_max;v++)\n'...
'                        {\n'...
'                            sum_hist[0]=sum_hist[1];\n'...
'                            sum_hist[1]=sum_hist[2];\n'...
'                            sifa=PI*v/a;\n'...
'                            denom=(gk[m]*gk[m]*100+(PI*v)*(PI*v)/(a2*100));\n'...
'                            sum_hist[2]=sum_hist[1]+v*sin(sifa*zzz)*\n'...
'                            exp(-.5*denom*(t-lower_t)-2*log(denom));\n'...
'                            if ((absol(sum_hist[0]-sum_hist[1])<delta) &&\n'...
'                            (absol(sum_hist[1]-sum_hist[2])<delta) && (sum_hist[2]>0))\n'...
'                                break;\n'...
'                        }\n'...
'                        sum_z+=.5*w_g[i]*(ser-4*sum_hist[2])*(PI/100)/\n'...
'                        (a2*st)*exp((2*x-1)*zzz*gk[m]*100);\n'...
'                    }\n'...
'                }\n'...
'                else\n'...
'                {\n'...
'                    sum_hist[0] = 0;\n'...
'                    sum_hist[1] = 0;\n'...
'                    sum_hist[2] = 0;\n'...
'                    su=-(Z_U*Z_U)/(12*a2)+(Z_U*Z_U*Z_U)/\n'...
'                    (12*a*a2)-(Z_U*Z_U*Z_U*Z_U)/(48*a2*a2);\n'...
'                    sl=-(Z_L*Z_L)/(12*a2)+(Z_L*Z_L*Z_L)/\n'...
'                    (12*a*a2)-(Z_L*Z_L*Z_L*Z_L)/(48*a2*a2);\n'...
'                    for (v=1;v<v_max;v++)\n'...
'                    {\n'...
'                        sum_hist[0]=sum_hist[1];\n'...
'                        sum_hist[1]=sum_hist[2];\n'...
'                        sifa=PI*v/a;\n'...
'                        denom=(PI*v)*(PI*v)/(a2*100);\n'...
'                        sum_hist[2]=sum_hist[1]+1/(PI*PI*PI*PI*v*v*v*v)*(cos(sifa*Z_L)-\n'...
'                        cos(sifa*Z_U))*exp(-.5*denom*(t-lower_t));\n'...
'                        if ((absol(sum_hist[0]-sum_hist[1])<delta) &&\n'...
'                        (absol(sum_hist[1]-sum_hist[2])<delta) && (sum_hist[2]>0))\n'...
'                            break;\n'...
'                    }\n'...
'                    sum_z=400*a2*a*(sl-su-sum_hist[2])/(st*sZ);\n'...
'                }\n'...
'                sum_nu+=sum_z*w_gh[m];\n'...
'            }\n'...
'            Fnew=(p0*(1-x)+p1*x)-sum_nu;\n'...
'        }\n'...
'    }\n'...
'    else if (t-Ter+st/2<=min_RT) /* is t lower than lower boundary Ter distr? */\n'...
'    {\n'...
'        Fnew=0;\n'...
'    }\n'...
'    \n'...
'    Fnew = Fnew>delta ? Fnew : 0;\n'...
'    \n'...
'    return Fnew;\n'...
'}\n'],nr_nu,nr_z,nr_nu,nr_z,nr_nu,gkstr,nr_nu,w_ghstr,nr_z,gzstr,nr_z,w_gstr);

function R = ghnodes(norder)
% GHNODES  Calculates Gauss-Hermite quadrature points and weights
%  Example call:  R = vpa(glnodes(10),20);
%  (Based on code from FEX by John Burkardt)

cc=sqrt(pi)*gamma(norder)/(2.0^(norder-1));
s=(2.0*norder+1.0)^(1.0/6.0);

nn = floor((norder+1)/2);
weight = zeros(1,nn);
for i=1:nn
    if(i==1),        x=s^3-1.85575/s;
    elseif(i==2),    x=x-1.14*((norder)^0.426)/x;
    elseif(i==3),    x=1.86*x-0.86*xtab(1);
    elseif(i==4),    x=1.91*x-0.91*xtab(2);
    else             x=2.0*x-xtab(i-2);
    end
    [x,dp2,p1]=hermite_root(x,norder);
    xtab(i)=x;
    weight(i)=(cc/dp2)/p1;
    xtab(norder-i+1)=-x;
    weight(norder-i+1)=weight(i);
end
% Reverse the order of the XTAB values.
xtab(1:norder) = xtab(norder:-1:1);
R = [xtab' weight'];

%%
function [x,dp2,p1] = hermite_root(x,norder)
for i=1:10
    [p2,dp2,p1] = hermite_recur(x,norder);
    d=p2/dp2;
    x=x-d;
    if (abs(d)<=1e-12*(abs(x)+1)), return, end
end

%%
function [p2,dp2,p1] = hermite_recur(x,norder)
p1 = 1;
dp1 = 0;
p2 = x;
dp2 = 1;
for i=2:norder
    p0=p1;
    dp0=dp1;
    p1=p2;
    dp1=dp2;
    p2=x*p1-0.5*(i-1)*p0;
    dp2=x*dp1+p1-0.5*(i-1)*dp0;
end

%%
function R=glnodes(n)
% GLNODES  Calculates Gauss-Legendre quadrature points and weights
%
%  Example call:
%     R = vpa(glnodes(10),20);

% Legendre polynomial
p(1,1)=1;
p(2,1:2)=[1 0];
for k=2:n
   p(k+1,1:k+1)=((2*k-1)*[p(k,1:k) 0]-(k-1)*[0 0 p(k-1,1:k-1)])/k;
end

x=roots(p(n+1,:));%roots
pn=polyder(p(n+1,:));%derivative

% coefficients
C = zeros(1,n);
for i=1:n
   C(i)=2./((1-x(i).^2).*((polyval(pn,x(i))).^2));
end
[x a] = sort(x);
R=[x C(a)'];