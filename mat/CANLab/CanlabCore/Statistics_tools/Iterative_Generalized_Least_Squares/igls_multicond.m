function [out, out_extended] = igls_multicond(y, xx, varargin)% function [out, out_extended] = igls_multicond(y, x, [optional arguments])%% Variance Component Estimation using IGLS/RIGLS% Multiple condition case%% y = d + c1*x1 + .... + cp*xp + epsilon where z is an optional covariate and epsilon is an AR(p) process%% d ~ N(0, sigma_d) and ci ~ N(0, sigma_ci)%% Calculate sigma using the Yule-Walker method. Calculate d, ci, b, sigma_d% and sigma_ci using Maximum Likelihood methods (IGLS) and Restricted Maximum Likelihood methods (RIGLS).%% This program is based on methods which are described in the following% papers:%% Goldstein, H. (1986). Multilevel mixed linear model analysis using%   iterative generalized least squares. Biometrika 73, 43-56.% Goldstein, H. (1989). Restricted unbiased iterative generalized%   least-squares estimation, Biometrika 76, 622-623.%% Inputs:% ----------------------------------------------------------------% y - matrix T x subjects% x - cell array of T x subjects matrices (one cell for each regressor except intercept)%     Note: Variance component test performed on first regressor only%% OPTIONAL ALTERNATIVE INPUT FORMAT:% same as glmfit_multilevel.m% y = cell array with one cell per subject, column vector of subject% outcome data in each cell.%% x = cell array with one cell per subject, design matrix for each% subject in each cell.  *columns must code for the same variable for% all subjects*%% Optional inputs% ----------------------------------------------------------------% 'covariate'   includes T x subjects 1st level covariate matrix or%               subjects x 1 2nd level covariate vector. The dimensions%               dictate the level.% 'noverbose'   suppress verbose output% 'iter'        max number of iterations% 'type'        'i' for igls (default) or 'r' for rigls% 'eps'         epsilon for convergence : all changes < (epsilon * beta)% 'ar'          order of AR(p) process; default is 0 (no AR model)% 'within_var'  specify common variance within subjects% 'plot'        followed by 'all' (for matrices) or 'slopes' for summary only%               or 'design' for design matrix and VIFs%% Outputs: Saved in fields of out.(fieldname)% ----------------------------------------------------------------% beta: Group intercept and slope estimates%   - vector of length p. Contains estimates of d and ci.%   (d is intercept and ci are the slopes)% betastar: Between-subjects (2nd level) error estimates%   - vector of length p. Contains estimates of sigma_d^2 (intercept variance) and%   sigma_ci^2 (slope variance).% Sigma: Within-subjects error estimates%   - vector of length sub. Contains an estimate of sigma for each%   subject.% Cov_beta - matrix p x p. Contains covariance matrix for beta (regression coefficients).%   - diagonals are variances, off-diagonals are covariances%% Cov_betastar - matrix p x p. Contains covariance matrix for betastar (variances).% iterations - number of iterations performed% elapsed_time - amount of time needed to run program%% By Martin Lindquist, April 2007% Edits: Tor Wager, June 2007% See programmers' notes in function for complete list of edits.%% Example: Create simulated data and test% ----------------------------------------------------------------% clear y x% len = 200; sub = 20;% x = zeros(len,sub);% x(11:20,:) = 2;                   % create signal% x(111:120,:) = 2;%% x = mat2cell(x, size(x, 1), ones(1, size(x, 2)));% y = mat2cell(y, size(y, 1), ones(1, size(y, 2)));%% c = normrnd(0.5,0.1,sub,1);       % slope between-subjects variations% d = normrnd(3,0.2,sub,1);         % intercept between-subjects variations%% for i=1:sub, y(:,i) = d(i) + c(i).*x(:,i) + 2*i + normrnd(0,0.5,len,1); end%% out = igls_multicond(y, x)  % for igls% disp('Input random-effect variances: '); disp(std([d c]))% disp('Est.  random-effect variances: '); disp(sqrt(out.betastar)');%% Examples of more complete calls with optional arguments:% ----------------------------------------------------------------% out = igls_multicond(y, x, 'type','r', 'iter', 10); beta,betastar% out = igls_multicond(y, x, 'ar', 2,'type','i', 'iter', 10, 'epsilon', .00001); beta, betastar% out = igls_multicond(y, x,'type','r', 'noverbose'); beta,betastar%% [out, out_extended] = igls_multicond(y, x);% create_figure('fits', 1, 2); plot(y, 'k'); plot(out_extended.rfxfit, 'r'); title('RFX fit');% subplot(1, 2, 2); plot(y, 'k'); plot(out_extended.fixedfxfit, 'r'); title('Fixed fx fit')%%% Small example, for matrix imaging% ----------------------------------------------------------------% len = 20; sub = 5;    randslopevar = 1; randintvar = 1; withinerr = 1;% fixedslope = 1; fixedint = 1;% x = zeros(len,sub); x(1:2:10, :) = 1;  % fixed-effect signal (same for all subs)% c = normrnd(fixedslope,randslopevar,sub,1);       % slope between-subjects variations% d = normrnd(fixedint,randintvar,sub,1);  % intercept between-subjects variations% clear y% for i=1:sub, y(:,i) = d(i) + c(i).*x(:,i) + normrnd(0,withinerr,len,1); end% out = igls_multicond(y, x, 'plot', 'all')  % for igls%%% Example: Simulation with second level covariate% ----------------------------------------------------------------%    %%     len = 200; sub = 20;%     x = zeros(len,sub);%     x(11:20,:) = 2;                   % create signal%     x(111:120,:) = 2;%% x = mat2cell(x, size(x, 1), ones(1, size(x, 2)));% y = mat2cell(y, size(y, 1), ones(1, size(y, 2)));%%     c = normrnd(0.5,0.1,sub,1);       % slope between-subjects variations%     d = normrnd(3,0.2,sub,1);         % intercept between-subjects variations%%     for i=1:sub, y(:,i) = d(i) + c(i).*x(:,i) + 2*i + normrnd(0,0.5,len,1); end;%%     out = igls_multicond(y, x,'covariate',(1:20));  % for igls%     disp('Input random-effect variances: '); disp(std([d c]))%     disp('Est.  random-effect variances: '); disp(sqrt(out.betastar)');%% Example: Add a second first-level regressor with random values%     X = {x};%     X{2} = rand(size(x));%     out = igls_multicond(y, X, 'iter', 10, 'names', {'temperature' 'pain rating'});  % for igls% Programmers' notes% --------------------------------------------------------------------%% Created 5/29/2007 by Martin Lindquist% Edits: 5/29, Tor; minor code rearrangement; results identical with%   original version on test data%   Replaced epsilon with data-dependent criterion%   Speeded up code : almost 2 x as fast with \ operator and avoiding%   growing arrays%   1.69 s on example code for 5 iterations%   Added optional arguments: type and verbose% Edits: 7/1, Martin; Edited solution of betastar. Edited bug that%   was underestimating the variance of betastar. Included option%   to allow for common within subject variance acroos subjects.% Edits 7/13: Tor: plotting functions, optional inputs, more bookkeeping% Edits: 1/14/08: Martin: Implemented Likelihood Ratio Test for testing%   the significance of the variance components.% Edits: 3/7/08: T & M: take cell inputs /optional% Edits: 7/14/08: Martin: Allowed for either 1st or 2nd level covariate.% Edits: 1/5/09: Include significance test for random slope model, i.e.%   when sigma_d == 0% Edits: 10/10/12: Extended to allow for multiple conditions% Edits: 10/15/2012: Tor - improve documentation% Edits: Tor, 3/1/2013 - fixed naming bug when including covariate%           added design plot option% Tor, 5/16/2015: Tor: added variance explained, update documentation% Simulation: Multiple conditions% len = 200; sub = 10;% x1 = zeros(len,sub);% x1(11:20,:) = 2;                   % create signal% x1(111:120,:) = 2;% x2 = zeros(len,sub);% x2(61:70,:) = 2;                   % create signal% x2(161:170,:) = 2;% c1 = normrnd(1,0.5,sub,1);       % slope between-subjects variations% c2 = normrnd(2,0.3,sub,1);         % intercept between-subjects variations% d = normrnd(3,0.2,sub,1);         % intercept between-subjects variations% for i=1:sub, y(:,i) = d(i) + c1(i).*x1(:,i) + c2(i).*x2(:,i)  + normrnd(0,0.5,len,1); end;% xx{1} = x1;% xx{2} = x2;% out = igls_2012(y, xx);  % for iglsc1= clock;% outputsPhi = [];% defaults% -------------------------------------------------------------------epsilon = 0.01;                % Convergence criterion: Min change in beta * epsilonnum_iter = 5;doverbose = 1;docovariate = 0;level = 1;                     % Determines which level to apply covariatearorder = 0;                   % or Zero for no ARtype = 'i';within = 'common';% doplot = 'slopes';doplot='none';beta_names = {'Intcpt.' 'Slope1'};  % default namesif ~iscell(xx), error('x input must be cell array.'); end% optional inputs% -------------------------------------------------------------------for varg = 1:length(varargin)    if ischar(varargin{varg})        switch varargin{varg}            % reserved keywords            case 'covariate', docovariate = 1; x_c = varargin{varg+1};            case 'verbose', doverbose = 1;            case 'noverbose', doverbose = 0;            case {'iterations', 'iter'}, num_iter = varargin{varg+1};            case 'type', type = varargin{varg+1}; varargin{varg+1} = [];            case {'epsilon', 'eps'}, epsilon = varargin{varg+1};            case {'ar', 'arorder'} , arorder = varargin{varg+1};            case {'within_var', 'within'} , within = 'unique_est';            case {'noplot'}, doplot = 'off';            case {'plot'}, doplot = varargin{varg + 1}; varargin{varg + 1} = [];            case 'names', beta_names = varargin{varg + 1};                            otherwise, if doverbose, disp(['Unknown input string option: ' varargin{varg}]); end                        end    endend% enforce matrix, padding if necessary; convert from cell input if% necessary%    [y, x] = cell2matrix(y, x);% check typeswitch type    case 'i', analysisname = 'IGLS: Iterative generalized least squares analysis';    case 'r', analysisname = 'RIGLS: Restricted iterative generalized least squares analysis';    otherwise        error('Type must be ''i'' (igls) or ''r'' (rigls)');end% Allow user to enter data in same format as GLMFIT_MULTILEVEL% reformat if necessaryif iscell(y)    y = cat(2, y{:});        Xi = {};    for i = 1:size(xx{1}, 2) % for each regressor        for j = 1:size(xx, 2) % for each subject            Xi{i}(:, j) = xx{j}(:, i);        end    end        xx = Xi;end% sizes, etc.% -------------------------------------------------------------------% T,        time points for subjects (same across subjects)% sub,      number of subjects% T2,       num. elements in lower triangle of cov matrix% len =     total # obs% n_G       # rows in G% z         data, (Y1 Y2 ... Ysub)'% D         within-subjects design, blk diagonal[T, sub] = size(y);                             % Length of y vector (Time) x Number of subjectsT2 = T * (T + 1) ./ 2;                          % num. elements in lower triangle of cov matrixlen = sub * T;                                  % Total number of observationsn_G = sub * T2;                                 % number of rows in var-comp est. design matrixp = length(xx)+1;                                 % number of regressorsz = reshape(y,len,1);                           % Concatenated data, T within sub%%%% Covariate not done yet...if (docovariate == 1)        % If x_c is a vector than covariate is applied to 2nd level, if it is a    % matrix than it is applied to the 1st level        switch numel(x_c)        case sub            % Set-up second level covariates            % enforce column format input            if length(x_c) > size(x_c, 1), x_c = x_c'; end                        x_c = scale(x_c, 1);                   % Mean-center covariates across sub            x_c = repmat(x_c',T,1);            level = 2;                    case len            % We have first-level covariate, T x sub                        x_c = scale(x_c, 1);                   % Mean-center covariates across time            level = 1;        otherwise            error(sprintf('Covariate must be %3.0f x 1 vector for 2nd level or %3.0f x %3.0f matrix for 1st level', sub, sub, T));    end        x_cvec = reshape(x_c,len,1);        D = [zeros(len,1)+1];          % Design matrix    b1 = {'Intcpt.'};    b2 = {'Covariate_intcpt'};        % note: tor added cov intercept as a regressor to D. 3/1/2013        for n=1:length(xx)        % Add each within-person regressor to design matrix D        D = [D reshape(xx{n},len,1)];                % Add names for slope and for covariate effects        b1{n+1} = strcat('Slope',num2str(n));        b2{n+1} = strcat('Covariate_slope',num2str(n));    end        % Design includes [intercept : within : cov_intercept : within*cov]    D = [D D.*repmat(x_cvec,1,size(D,2))];    %beta_names{1:(n+1)} = b1;    beta_names(1:(n+1)) = b1;    %beta_names{(n+2):(2*n+1)} = b2;    beta_names((n+2):(2*n+1)+1) = b2;    else % no covariate        D = [ones(len,1)];          % Design matrix    beta_names = {'Intcpt.'};    for n=1:length(xx)                           % For each regressor number (cell of xx)        D = [D reshape(xx{n}, len, 1)];          % Design matrix        beta_names{n+1} = strcat('Slope',num2str(n));    endend% Remove NaNs[whnan, D, z] = nanremove(D, z);switch doplot    case {'all' 'slopes' 'design'}        create_figure('design'); plot_matrix_cols(D);        vifs = getvif(D(:,2:end));        create_figure('Variance inflation factors (without intercept)');        plot(vifs, 'ko', 'MarkerSize', 8);        plot_horizontal_line(1);        end%%% Stopped here%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Step 1: Find the OLS solution%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%beta = D \ z;                                           % Beta valuesresid = z - D * beta;                                   % Residualssig_tmp = resid'*resid / (len-2);             % sigma^2, SS / dfCov_beta = sig_tmp.*inv(D'*D);                % Set initial values for the covariance of beta, beta_no_c and beta_no_dCov_beta_no_c = Cov_beta;                     % Needed for REML estimationCov_beta_no_d = Cov_beta;Cov_beta_no_cd = Cov_beta;% Create regressors corresponding to within subject variance.% Dimensions depend on whether one assumes common variance across% subjects.if (strcmp(within, 'common'))    V = zeros(n_G,1);    ind_c = ones(1,p+1);    ind_d = ones(1,p+1);    ind_cd = ones(1,p+1);else    V = zeros(n_G,sub);    ind_c = ones(1,p+sub);    ind_d = ones(1,p+sub);    ind_cd = ones(1,p+sub);endSigma = zeros(sub,1);Sig = zeros(len,len);                         % Covariance matrixiSig = eye(len,len);                          % Inverse of covariance matrixSig_no_d = zeros(len,len);                    % Covariance matrix for reduced model with sigma_d=0 (needed for LRT).iSig_no_d = eye(len,len);                     % Inverse of covariance matrixSig_no_c = zeros(len,len);                    % Covariance matrix for reduced model with sigma_c=0 (needed for LRT).iSig_no_c = eye(len,len);                     % Inverse of covariance matrixSig_no_cd = zeros(len,len);                    % Covariance matrix for reduced model with sigma_d =0 and sigma_c=0 (needed for LRT).iSig_no_cd = eye(len,len);                     % Inverse of covariance matrixif arorder > 0    Phi = zeros(sub,arorder);    get_ar                                              % updates Phi, Sigma, and -> V (from Sigma)else    get_V_no_arendystar = zeros(n_G, 1);                                  % Sums of squared residuals, concatenated across Ssystar_no_c = zeros(n_G, 1);                             % SSR for reduced model 1ystar_no_d = zeros(n_G, 1);                             % SSR for reduced model 2ystar_no_cd = zeros(n_G, 1);                             % SSR for reduced model 3resid_no_c = resid;                                     % Set temporary values needed for first iteration.resid_no_d = resid;resid_no_cd = resid;get_ystar;% Fit the variance parameter design matrix to ystar, est. residual variancesG = Create_Design_Eq2(xx,V);                            % Create design matrix for variance estimationbetastar = G \ ystar;                                   % Estimate variance componentsbetastar(betastar < 0) = 0;                             % Use max(0,betastar) to ensure nonnegative variance.% Reduced model 1ind_d(1) = 0;tt_d = (ind_d == 1);betastar_no_d = G(:,tt_d) \ ystar;                      % Estimate variance components when sigma_d=0betastar_no_d(betastar_no_d < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.% Reduced model 2ind_c(2) = 0;tt_c = (ind_c == 1);betastar_no_c = G(:,tt_c) \ ystar;                      % Estimate variance components when sigma_c=0betastar_no_c(betastar_no_c < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.% Reduced model 3ind_cd(1:2) = 0;tt_cd = (ind_cd == 1);betastar_no_cd = G(:,tt_cd) \ ystar;                      % Estimate variance components when sigma_d=0 and sigma_c=0betastar_no_cd(betastar_no_cd < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Step 2: Iterate%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%iterations = 0;min_change = betastar * epsilon;isconverged = 0;while (iterations < num_iter) && ~isconverged    num = size(G,1) / sub;    for s = 1:sub                Sig1 = ivech(G(((s-1) * num + 1):(s * num),:) * betastar);        Sig1 = Sig1 + tril(Sig1,-1)';                wh = ((s-1)*T+1):(s*T);                   % which indices in Cov mtx for this subject        Sig(wh, wh) = Sig1;        iSig(wh, wh) = inv(Sig(wh, wh));                % Cov mtx when sigma_d = 0        Sig1_no_d = ivech(G(((s-1) * num + 1):(s * num),tt_d) * betastar_no_d);        Sig1_no_d = Sig1_no_d + tril(Sig1_no_d,-1)';        Sig_no_d(wh, wh) = Sig1_no_d;        iSig_no_d(wh, wh) = inv(Sig_no_d(wh, wh));                % Cov mtx when sigma_c = 0        Sig1_no_c = ivech(G(((s-1) * num + 1):(s * num),tt_c) * betastar_no_c);        Sig1_no_c = Sig1_no_c + tril(Sig1_no_c,-1)';        Sig_no_c(wh, wh) = Sig1_no_c;        iSig_no_c(wh, wh) = inv(Sig_no_c(wh, wh));                % Cov mtx when sigma_c = 0 and sigma_d = 0        Sig1_no_cd = ivech(G(((s-1) * num + 1):(s * num),tt_cd) * betastar_no_cd);        Sig1_no_cd = Sig1_no_cd + tril(Sig1_no_cd,-1)';        Sig_no_cd(wh, wh) = Sig1_no_cd;        iSig_no_cd(wh, wh) = inv(Sig_no_cd(wh, wh));                    end        Cov_beta = inv(D'*iSig*D);    Cov_beta_no_c = inv(D'*iSig_no_c*D);    Cov_beta_no_d = inv(D'*iSig_no_d*D);    Cov_beta_no_cd = inv(D'*iSig_no_cd*D);        beta = Cov_beta*D'*iSig*z;                              % Beta values    resid = z - D*beta;                                     % Residuals        beta_no_d = Cov_beta_no_d*D'*iSig_no_d*z;               % Beta values when sigma_d=0    resid_no_d = z - D*beta_no_d;                           % Residuals        beta_no_c = Cov_beta_no_c*D'*iSig_no_c*z;               % Beta values when sigma_c=0    resid_no_c = z - D*beta_no_c;                           % Residuals        beta_no_cd = Cov_beta_no_cd*D'*iSig_no_cd*z;            % Beta values when sigma_d=0 and sigma_c=0    resid_no_cd = z - D*beta_no_cd;                         % Residuals            betastar_old = betastar;        get_ystar;        beta_indiv = get_indiv_betas;   % params x subjects matrix of betas        betastar = G \ ystar;    betastar(betastar < 0) = 0;                             % Use max(0,betastar) to ensure nonnegative variance.        betastar_no_d = G(:,tt_d) \ ystar_no_d;    betastar_no_d(betastar_no_d < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.        betastar_no_c = G(:,tt_c) \ ystar_no_c;    betastar_no_c(betastar_no_c < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.        betastar_no_cd = G(:,tt_cd) \ ystar_no_cd;    betastar_no_cd(betastar_no_cd < 0) = 0;                   % Use max(0,betastar) to ensure nonnegative variance.            isconverged = ~any(abs(betastar - betastar_old) > abs(min_change));    iterations = iterations + 1;    end % iterationsCov_beta = inv(D'*iSig*D);%W = (Sigma - D*inv(D'*iSigma*D)*D');        % Residual inducing matrix x Sigmadf_beta = sub - p;          % this should be sub - q, # params in Xg, but we haven't added this flexibility yet%df_beta = (trace(W).^2)./trace(W*W);       % Satterthwaite approximation for degrees of freedomCov_betastar = inv(G'*G);df_betastar = sub - 1;Sigma = betastar((p+1):end);yhat = G*betastar;e = ystar - yhat;tau = e'*e/(size(G,1)-size(G,2));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Likelihood ratio tests%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%detmat = zeros(sub,1);detmat_no_d = zeros(sub,1);detmat_no_c = zeros(sub,1);detmat_no_cd = zeros(sub,1);detDSigD = 0;detDSigD_no_d = 0;detDSigD_no_c = 0;detDSigD_no_cd = 0;for k=1:sub        wh = ((k-1) * T + 1):(k * T);    detmat(k) = abs(det(Sig(wh,wh)));    detmat_no_d(k) = abs(det(Sig_no_d(wh,wh)));    detmat_no_c(k) = abs(det(Sig_no_c(wh,wh)));    detmat_no_cd(k) = abs(det(Sig_no_cd(wh,wh)));        detDSigD = detDSigD+abs(det(D(wh,:)' * iSig(wh,wh) * D(wh,:)));    detDSigD_no_d = detDSigD_no_d+abs(det(D(wh,:)' * iSig_no_d(wh,wh) * D(wh,:)));    detDSigD_no_c = detDSigD_no_c+abs(det(D(wh,:)' * iSig_no_c(wh,wh) * D(wh,:)));    detDSigD_no_cd = detDSigD_no_cd+abs(det(D(wh,:)' * iSig_no_cd(wh,wh) * D(wh,:)));    end;%%%%%% Test H0: sigma_d = 0 %%%%%%LLd = - 0.5*( sum(log(detmat_no_d))-sum(log(detmat)) + (resid_no_d'* iSig_no_d * resid_no_d - resid'* iSig * resid));if (type == 'r'),    LLd = -0.5*(log(detDSigD_no_d) - log(detDSigD) + sum(log(detmat_no_d))-sum(log(detmat)) +...        (resid_no_d'* iSig_no_d * resid_no_d - resid'* iSig * resid));end;LRd = max(-2*LLd,0);% Calculate null distribution using a 50:50 mixtureV = 0.5*(chi2rnd(p-1,1000000,1)) + 0.5*(chi2rnd(p,1000000,1));randvariance_d = mean(V>LRd);%%%%%% Test H0: sigma_c = 0 %%%%%%LLc = - 0.5*( sum(log(detmat_no_c))-sum(log(detmat)) + (resid_no_c'* iSig_no_c * resid_no_c - resid'* iSig * resid));if (type == 'r'),    LLc = -0.5*(log(detDSigD_no_c) - log(detDSigD) + sum(log(detmat_no_c))-sum(log(detmat)) +...        (resid_no_c'* iSig_no_c * resid_no_c - resid'* iSig * resid));end;LRc = max(-2*LLc,0);randvariance_c = mean(V>LRc);%%%%%% Test H0: sigma_c = 0 when sigma_d = 0, i.e. a random slope model %%%%%%LLcd = - 0.5*( sum(log(detmat_no_cd))-sum(log(detmat_no_d)) + (resid_no_cd'* iSig_no_cd * resid_no_cd - resid_no_d'* iSig_no_d * resid_no_d));if (type == 'r'),    LLcd = -0.5*(log(detDSigD_no_cd) - log(detDSigD_no_d) + sum(log(detmat_no_cd))-sum(log(detmat_no_d)) +...        (resid_no_cd'* iSig_no_cd * resid_no_cd - resid_no_d'* iSig_no_d * resid_no_d));end;LRcd = max(-2*LLcd,0);% Calculate null distribution using a 50:50 mixtureV = 0.5*(chi2rnd(p-2,1000000,1)) + 0.5*(chi2rnd(p-1,1000000,1));randvariance_cd = mean(V>LRcd);betastar = betastar(1:p);                       % Remove within subject varianceCov_betastar = Cov_betastar(1:p,1:p);           % Remove within subject variance%     % Include covariates in output%     if (docovariate == 1)%         if (level == 2)%             Cov_beta = blkdiag(Cov_beta, Cov_beta);%             beta = [beta; beta_c];%         else%             Cov_beta = blkdiag(Cov_beta, Cov_beta_c);%             beta = [beta; beta_c];%         end%     endc2 = clock;elapsed_time = etime(c2, c1);% save output structurenames = {'Y1'}; % later;varnames = {'analysisname', 'names', 'beta_names', 'type', 'num_iter', 'epsilon', 'arorder', 'within', 'y', 'x'};%   b = create_struct(varnames);out = struct('analysisname', analysisname, 'beta', beta, 'betastar', betastar, 'beta_indiv', beta_indiv, 'beta_names', {beta_names}, ...    'Cov_beta', Cov_beta, 'Cov_betastar', Cov_betastar, ...    'Sigma', Sigma, 'Phi', Phi, ...    'type', type, 'arorder', arorder, 'isconverged', isconverged, ...    'num_obs', T, 'sub', sub, 'num_iter', num_iter, 'epsilon', epsilon, ...    'iterations', iterations, 'elapsed_time', elapsed_time);% , 'inputOptions', inputOptions);% save statsout.ste = sqrt(diag(out.Cov_beta));out.t = out.beta ./ out.ste;out.df_beta = df_beta;out.p = 2 * (1 - tcdf(abs(out.t), out.df_beta));  % two-tailedout.p(out.p == 0) = eps;out.p_tails = 'two-tailed';out.t_randvariance = out.betastar ./ sqrt(diag(out.Cov_betastar));out.df_betastar = df_betastar;out.p_randvariance = (1 - tcdf(abs(out.t_randvariance), out.df_betastar)); % one-tailedout.p_randvariance(out.p_randvariance == 0) = eps;out.p_randvariance_tails = 'one-tailed';out.LRT = [LRd; LRc];out.LRT_RSM = LRcd;out.pLRT_randvariance = [randvariance_d; randvariance_c];out.pLRT_randvariance_RSM = randvariance_cd;if strcmp(doplot, 'all')        plot_igls_matrices    igls_plot_slopes(out, x);    elseif strcmp(doplot, 'slopes')        igls_plot_slopes(out, x);    end% print outputif doverbose    print_output_text(out)endif nargout > 1        % print output if requested    calculate_variance_explained_and_output    end% _________________________________________________________________________%%%% * Inline (nested) functions%%%%__________________________________________________________________________    function newstruct = create_struct(varnames)                newstruct = struct();                for i = 1:length(varnames)            eval(['newstruct.(varnames{i}) = ' varnames{i} ';']);        end            end    function [beta_indiv] = get_indiv_betas        % beta_indiv is params x subjects matrix                % Reexpress design matrix depending on whether or not the covariate        % is applied to the 1st or second level.        DD = D;        if (level == 2)            %            DD = DD(:,1:(end-1));       %Remove second level covariate from design matrix                        %            DD = DD(:,1:(end-2));       %Remove second level covariate from design matrix            DD = DD(:,1:(end-p));       %Remove second level covariate from design matrix                    end                beta_indiv = zeros(size(DD,2),sub);                for k = 1:sub            % Estimate AR parameters using the Yule-Walker method for each subject.            wh = ((k-1) * T + 1):(k * T);            beta_indiv(:,k) = inv(DD(wh,:)' * iSig(wh,wh) * DD(wh,:)) * DD(wh,:)' * iSig(wh,wh) * z(wh, 1);            sigma_indiv(k) = mean(diag(Sig(wh, wh)));                        %% for plotting: need weight estimates for each subject                    end            end    % INLINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    function get_V_no_ar                mysig = vech(eye(T));                for k = 1:sub            wh = ((k-1) * T2 + 1):(k * T2);                             % indices in time series for this subject            if (strcmp(within, 'common'))                V(wh) = mysig;                                          % Create one regressor for common variance            else                V(wh,k) = mysig;                                        % Cretae m regressors otherwise            end        end    end    % INLINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    function get_ar                % %         beta_indiv = zeros(size(D,2),sub);                for k = 1:sub            % Estimate AR parameters using the Yule-Walker method for each subject.            wh = ((k-1) * T + 1):(k * T);                        [a,e] = aryule(resid(wh), arorder);                % Yule-Walker            Phi(k,:) = a(2:(arorder+1));                 % Parameters of AR(p) model            Sigma(k) = sqrt(e);                          % standard deviation of AR(p) model; ***not used?***                        % Find the covariance matrix                        A = diag(ones(T,1));            for j=1:arorder                A = A + diag(Phi(k,j)*ones((T-j),1),-j);            end                        wh = ((k-1) * T2 + 1):(k * T2);                             % indices in time series for this subject            iA = inv(A);            tmp = vech(iA * iA');            if strcmp(within, 'common')                %                V(wh) = Sigma(k)^2 * tmp;                                      % Covariance function in vech format                V(wh) = tmp;                                      % Covariance function in vech format            else                %                V(wh,k) = Sigma(k)^2 * tmp;                                      % Covariance function in vech format                V(wh,k) = tmp;                                      % Covariance function in vech format            end                                end    end    % INLINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    function get_ystar        if (type == 'i')           % IGLS            for i=1:sub                wh = ((i-1) * T + 1):(i * T);                              % indices in time series for this subject                myresid = resid( wh );                                     % residuals for this subject.                myresid_no_c = resid_no_c(wh );                myresid_no_d = resid_no_d(wh );                myresid_no_cd = resid_no_cd(wh );                                tmp = vech(myresid * myresid');                            % Find vech of estimated covariance                tmp_no_c = vech(myresid_no_c * myresid_no_c');                tmp_no_d = vech(myresid_no_d * myresid_no_d');                tmp_no_cd = vech(myresid_no_cd * myresid_no_cd');                                wh = ((i-1) * T2 + 1):(i * T2);                            % indices in time series for this subject                ystar(wh) = tmp;                ystar_no_c(wh) = tmp_no_c;                ystar_no_d(wh) = tmp_no_d;                ystar_no_cd(wh) = tmp_no_cd;            end        elseif (type == 'r')       % RIGLS                        DD = D;            if (level == 2)                DD = DD(:,1:(end-1));       %Remove second level covariate from design matrix            end                        for i=1:sub                wh = ((i-1) * T + 1):(i*T);                                  % indices in time series for this subject                Dtmp = DD(wh, :);                rtmp = resid(wh);                                            % residuals for this subject.                rtmp_no_c = resid_no_c(wh);                rtmp_no_d = resid_no_d(wh);                rtmp_no_cd = resid_no_cd(wh);                                rig = rtmp * rtmp' + Dtmp * Cov_beta * Dtmp';                tmp = vech(rig);                                                       % Find vech of estimated covariance                rig_no_c = rtmp_no_c * rtmp_no_c' + Dtmp * Cov_beta_no_c * Dtmp';                tmp_no_c = vech(rig_no_c);                                             % Find vech of estimated covariance                rig_no_d = rtmp_no_d * rtmp_no_d' + Dtmp * Cov_beta_no_d * Dtmp';                tmp_no_d = vech(rig_no_d);                                             % Find vech of estimated covariance                rig_no_cd = rtmp_no_cd * rtmp_no_cd' + Dtmp * Cov_beta_no_cd * Dtmp';                tmp_no_cd = vech(rig_no_cd);                                             % Find vech of estimated covariance                                wh = ((i-1) * T2 + 1):(i * T2);                                % indices in time series for this subject                ystar(wh) = tmp;                ystar_no_c(wh) = tmp_no_c;                ystar_no_d(wh) = tmp_no_d;                ystar_no_cd(wh) = tmp_no_cd;                            end        end    end    % INLINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    function plot_igls_matrices                % Ystar_mtx:    Estimate of total covariance, var(ksi)        Ystar_mtx = single(resid * resid');                figh = create_figure(['IGLS Error Matrix Plot'], 2, 4);        for i = 1:7, subplot(2, 4, i); set(gca,'YDir', 'reverse'); end        subplot(2, 4, 8); axis off                titles = {'Cov(ksi) est.' 'Random intercept' 'Random slope' 'Within error' 'Fitted' 'residual'};                subplot(2, 4, 1);        s = std(Ystar_mtx(:));        clims = [-3 * s   3 * s];                imagesc(Ystar_mtx, clims)                title(titles{1})        xlabel('T * N');        ylabel('T * N');        axis image        text(T*sub + .01*T*sub, T*sub/2, '=','FontSize', 64)                % set color map; make zero values white        cm = zeros(256, 3);        cvec = abs(linspace(clims(1), clims(2), size(cm, 1)));        wh = find(cvec == min(cvec));        wh = wh(1);        hotpart = [linspace(.9, 1, length(cvec) - wh + 1)' linspace(1, 0, length(cvec) - wh + 1)' linspace(0, 0, length(cvec) - wh + 1)'];        cm(wh:end, :) = hotpart(end:-1:1, :);                coolpart = [linspace(0, 0, wh - 1)' linspace(0, 1, wh - 1)' linspace(1, .9, wh - 1)'];        cm(1:wh - 1, :) = coolpart;                cm(wh-1:wh+1, :) = repmat([.3 .3 .3], 3, 1);        colormap(cm)        drawnow                num_var_comps = size(G, 2) - length(Sigma);                % GGmtx: Cell array of matrix error covariance components        % -----------------------------------------        myest = [betastar; Sigma]; % one for each variance component estimated, then error        GGfit = sparse(zeros(T*sub, T*sub));                % get var. component matrices, not including Sigma (within error)        for k = 1:num_var_comps                        for i = 1:sub                wh = ((i-1) * T2 + 1):(i * T2);                             % indices in time series for this subject                GG{i} = ivech(G(wh, k));            end                        % fitted for this component            GGmtx{k} = sparse(blkdiag(GG{:})) .* myest(k);                        GGmtx{k} =  full_from_ltr( GGmtx{k} ); % full matrix form from lower triangle                        GGfit = GGfit + GGmtx{k};                                end                % now get the one for sigma (V)        % -----------------------------------------        wh_is_V = num_var_comps + 1;        GGmtx{wh_is_V} = sparse(zeros(T * sub, T * sub));                for k = 1:length(Sigma)            for i = 1:sub                wh = ((i-1) * T2 + 1):(i * T2);                             % indices in time series for this subject                GG{i} = ivech(G(wh, num_var_comps + k));            end                        % fitted error %%%M: THIS Line is giving me an error and seems            % wrong, but haven't figured out how yet.            GGmtx{wh_is_V} = GGmtx{wh_is_V} + sparse(blkdiag(GG{:})) .* myest(num_var_comps + k);        end                GGmtx{wh_is_V} =  full_from_ltr( GGmtx{wh_is_V} ); % full matrix form from lower triangle                GGfit = GGfit + GGmtx{wh_is_V};                % image them        % -----------------------------------------        for k = 1:num_var_comps + 1            subplot(2, 4, k + 1);            imagesc(GGmtx{k}, clims);                        title(sprintf('%s\nb-hat = %3.3f', titles{k+1}, myest(k)));            axis image            if k <= num_var_comps, text(T*sub + .01*T*sub, T*sub/2, '+','FontSize', 64), end            drawnow        end                subplot(2, 4, num_var_comps + 3);        imagesc(GGfit, clims)        title(titles{5})        axis image        drawnow                residmtx = double(Ystar_mtx) - GGfit;        clear GGfit        fprintf('MST (diag of Ystar_mtx): %3.5f\n', mean(diag(Ystar_mtx)));        fprintf('MSE (diag of resid): %3.5f\n', mean(diag(residmtx)));                axh = subplot(2, 4, num_var_comps + 4);        imagesc(residmtx, clims)        title(titles{6})        axis image        drawnow                axh2 = subplot(2, 4, num_var_comps + 5);        axes(axh2)        imagesc(residmtx, clims)        colorbar; %('peer', axh);        set(axh2,'Visible','off')            end    % INLINE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    function calculate_variance_explained_and_output                % D is design matrix for params of interest, concatenated across subjects        % beta is fixed effects betas                fixedfxfit = D * beta;                  % Fit with params constant across subjects, matrix form        rfxfit = zeros(size(fixedfxfit));        rfxfitbybeta = zeros(size(D));          % Fit with slopes/intercepts individualized per subject, concatenated form                k = size(beta_indiv, 1);                for s = 1:sub                        wh = ((s-1) * T + 1):(s * T);                        % total fit            rfxfit(wh, 1) = D(wh, :) * beta_indiv(:, s);                        % design, for rfxfit with individualized betas            Dmatrix(:, :, s) = D(wh, :);                        % individual fits including rfx (individualized) slopes            for i = 1:k                rfxfitbybeta(wh, :) = Dmatrix(:, :, s) * diag(beta_indiv(:, s));            end                    end                fixedfxfit = reshape(fixedfxfit, T, sub);        % Fit with params constant across subjects, matrix form        rfxfit = reshape(rfxfit, T, sub);                % Fit with slopes/intercepts individualized per subject, matrix form                resid = reshape(resid, T, sub);                 % Measurement error after accounting for fixed effects        rfxresid = y - reshape(rfxfit, T, sub);         % Measurement error after accounting for individualized fits                % variance explained        % ----------------------------------                % total variance = var(intcpt) + var(model) + var(resid)        % varytot = varrfxintercept + varexptotal + varr                varytot = var(y(:));                % variance of y removing random intercept only (removing individual        % subject means)        % this is the total variance in y, discounting the intercept        % vary = varexptotal + varr                vary = scale(y, 1);        vary = var(vary(:));                varrfxintercept = varytot - vary;                % residual variance        varr = var(rfxresid(:));                        % allowing each subjects's slopes to vary...        percentexpresid = 100 .* varr ./ vary;          % measurement error within person, allowing for individual slope (and intercept)                % total model var explained and percentage        varexptotal = vary - varr;        percentexptotal = 100 * varexptotal ./ vary;    % explained by model, allowing for individual slope as signal                % var and percent explained by fixed and random slopes        % vary = varexptotal + varr = varexpfixed + varexprand + varr                varexpfixed = var(fixedfxfit(:));               % same as fixed effects * n. subjects        percentexpfixed = 100 .* varexpfixed ./ vary;   % explained by model fixed effects                varexprand = varexptotal - varexpfixed;         % person x slope interaction: variance explained by individual slopes (error variance in rfx model = this + residual var)        percentexprand = 100 .* varexprand ./ vary;                % variance explained for individual regressors        % --------------------------------------------------        totalvarbybeta = var(rfxfitbybeta); % fixed + random                fixedfxfitbybeta = D * diag(beta);  % intercept is first. var(fixedfxfitbybeta) = varexpfixed for each regressor        fixedfxvarbybeta = var(fixedfxfitbybeta);                rfxvarbybeta = totalvarbybeta - fixedfxvarbybeta; % number slightly off other calc??  Maybe because not accounting for shared variance?                % output        %-------------------------------        mydescrip = sprintf('y = data fit without (fixed) and with (rfx) random effects\ndesign matrix D\nresid with residuals without (resid) and with (rfxresid) random effects\nwithin obs T\nnum. subjects sub\nVar(Y) removing random intercept vary\nVar explained by fixed fx varexpfixed\nVar explained by random slopes (individual diffs) varexprand\nResidual variance varresid\n');                out_extended = struct('y', y, 'fixedfxfit', fixedfxfit, 'rfxfit', rfxfit, 'resid', resid, 'rfxresid', rfxresid, 'D', D, 'T', T, 'sub', sub, 'descrip', mydescrip, ...            'vary', vary, 'varexpfixed', varexpfixed, 'varexprand', varexprand, 'varresid', varr, ...            'percentexpfixed', percentexpfixed, 'percentexprand', percentexprand, 'percentexpresid', percentexpresid, 'totalvarbybeta', totalvarbybeta, 'fixedfxvarbybeta', fixedfxvarbybeta, 'rfxvarbybeta', rfxvarbybeta);                if doverbose            fprintf('Variance decomposition\n---------------------------------------\n');                        fprintf('Var(Y) removing random intercept = Var(fixedfx) + Var(rfx) + Var(resid) \n')            fprintf('Var(Y) %3.4f = %3.4f + %3.4f + %3.4f \n', vary, varexpfixed, varexprand, varr)                        fprintf('\n%% Variance explained:\nFixed slopes\t%3.4f%%\nRandom slopes\t%3.4f%%\nResidual\t%3.4f%%\n\n',  percentexpfixed, percentexprand, percentexpresid);                        fprintf('\nVariance explained by each regressor\n---------------------------------------\n');            names = {'Total' 'Fixed' 'Rfx'};                        vmtx = [totalvarbybeta; fixedfxvarbybeta; rfxvarbybeta];            vmtx = vmtx(:, 2:end)'; % remove intercept            print_matrix(vmtx, names, beta_names(2:end))            fprintf('\n');                        names = {'% Total' '% Fixed' '% Rfx'};            vmtx = [100*(totalvarbybeta ./ vary); 100*(fixedfxvarbybeta ./ vary); 100*(rfxvarbybeta  ./ vary)];            vmtx = vmtx(:, 2:end)'; % remove intercept            print_matrix(vmtx, names, beta_names(2:end))        end            endend % END MAIN FUNCTION%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Subfunctions%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function G = Create_Design_Eq2(xx,V)% function G = Create_Design(x)%% Create Design matrix for estimation of variance components%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%p = length(xx)+1;[T, sub] = size(xx{1});T2 = T * (T+1) / 2;one = ones(T,sub);G = zeros(sub * T2, p);for i = 1:sub    wh = ((i-1) * T2 + 1):(i * T2);        for j=1:p        if (j == 1)            x = one;        else            x = xx{j-1};        end        G(wh,j) = vech(x(:,i) * x(:,i)');    end    endG = [G V];                              % use within-subject covariance as a regressorend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function V = vech(Mat)% function V = vech(Mat)%% Calculate vech for the matrix Mat%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%V = Mat(tril(true(size(Mat))));end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function Mat = ivech(V)% function Mat = vech(V)%% Calculate the "inverse" of the vech function% This is much faster than matlab's squareform.m% It could be speeded up, probably, by operating column-wise%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%len = length(V);dim = -0.5 + sqrt(0.25 + 2 * len);Mat = zeros(dim, dim);ind=1;for i=1:dim    for j=i:dim        Mat(j,i) = V(ind);        ind = ind+1;    endendend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function print_output_text(out)fprintf('\nigls.m output report:\n---------------------------------------\n');fprintf('Data: %3.0f observations x %3.0f subjects \n', out.num_obs, out.sub);typestr = {'igls' 'rigls'};nystr = {'No' 'Yes'};fprintf('Fit Type: %s\n', typestr{strcmp(out.type, 'r') + 1});fprintf('AR(p) model: %s', nystr{(out.arorder > 0) + 1});if out.arorder > 0    fprintf(', AR(%d)\n', out.arorder);else    fprintf('\n');endfprintf('Converged: %s\n', nystr{out.isconverged + 1});fprintf('Max iterations: %3.0f, Completed iterations: %3.0f\n', out.num_iter, out.iterations);fprintf('Epsilon for convergence: %3.6f\n', out.epsilon);fprintf('Elapsed time: %3.2f s\n', out.elapsed_time);fprintf('\nStatistics: Tests of inference on fixed population parameters\n')fprintf('Parameter\test.\tt(%3.0f)\tp\t\n', out.df_beta)sigstring = {' ' '+' '*' '**' '***'};for i = 1:length(out.beta)    % if i == 1, name = 'Intcpt.'; else name = ['Pred' num2str(i - 1)]; end   % names input above, at start    sig = out.p(i) < [Inf .1 .05 .01 .001];    fprintf('%s\t%3.3f\t%3.2f\t%3.6f\t%s\n', out.beta_names{i}, out.beta(i), out.t(i), out.p(i), sigstring{find(sig, 1, 'last')})endfprintf('\n\nStatistics: Tests of significance on random effects (variances)\n')%    fprintf('Parameter\test.\tt(%3.0f)\tp\t\n', out.df_betastar)fprintf('Parameter\test.\tLRT\tp\t\n')sigstring = {' ' '+' '*' '**' '***'};for i = 1:2    %if i == 1, name = 'Intcpt.'; else name = ['Pred' num2str(i - 1)]; end    if (~strcmp(out.beta_names(i),'Covariate_intcpt') && ~strcmp(out.beta_names(i),'Covariate_slope'))        %            sig = out.p_randvariance(i) < [Inf .1 .05 .01 .001];        %           fprintf('%s\t%3.3f\t%3.2f\t%3.6f\t%s\n', out.beta_names{i}, out.betastar(i), out.t_randvariance(i), out.p_randvariance(i), sigstring{find(sig, 1, 'last')})        sig = out.pLRT_randvariance(i) < [Inf .1 .05 .01 .001];        fprintf('%s\t%3.3f\t%3.2f\t%3.6f\t%s\n', out.beta_names{i}, out.betastar(i), out.LRT(i), out.pLRT_randvariance(i), sigstring{find(sig, 1, 'last')})    endendfprintf('\n---------------------------------------\n\n');end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function M = full_from_ltr(M)tmp2 = M;tmp2 = (  tmp2 .*  (1 - eye(size(tmp2)))  )';M = M + tmp2;end% This duplicates a function in the SCN Core toolbox, but is included to% make igls.m stand-alonefunction f1 = create_figure(tagname, varargin)% f1 = create_figure(['tagname'], [subplotrows], [subplotcols], [do not clear flag])%% checks for old figure with tag of tagname% clears it if it exists, or creates new one if it doesn'tif nargin < 1 || isempty(tagname)    tagname = 'nmdsfig';enddoclear = 1;    % clear if new or if old and existingif length(varargin) > 2 && varargin{3}    % use same figure; do not clear    doclear = 0;endold = findobj('Tag', tagname);if ~isempty(old)        if doclear, clf(old); end        f1 = old;    else    % Or create new        scnsize = get(0,'ScreenSize');        xdim = min(scnsize(3)./2, 700);    ydim = min(scnsize(4)./2, 700);        f1 = figure('position',round([50 50 xdim ydim]),'color','white');    set(f1, 'Tag', tagname, 'Name', tagname);end% activate this figurefigure(f1);if doclear % true for new figs or cleared ones        % Create subplots, if requested; set axis font sizes        if length(varargin) > 0        i = max(1, varargin{1});        j = max(1, varargin{2});    else        i = 1;        j = 1;    end        np = max(1, i * j);        for k = 1:np        axh(k) = subplot(i,j,k);        set(gca,'FontSize',18),hold on    end    axes(axh(1));    endendfunction [y, x] = cell2matrix(y, x)% one or none of y and x can be cell arraysif ~iscell(x) && ~iscell(y)    returnendif iscell(y)        if ~iscell(x), error('y and x must either both be cell arrays or neither can be.'); end        sz = zeros(size(y, 1), 2);    for i = 1:length(y)        sz(i, :) = size(y{i});    end            sz = sz(:, 1);        if all(sz) == sz(1)        % all the same?    else                mx = max(sz(:, 1));  % longest                for i = 1:length(y)                        if sz(i) < mx                mn = mean(y{i});                mnx = mean(x{i});                                y{i} = [y{i}; mn(ones(mx - sz(i), 1))];                                % assume y and x match and are both cells                x{i} = [x{i}; mnx(ones(mx - sz(i), 1))];            end        end    end        %turn into matrix    y = cell2mat(y);    x = cell2mat(x);    endend