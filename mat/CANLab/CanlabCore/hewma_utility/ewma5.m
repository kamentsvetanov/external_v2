function [SMap, SMapTh, CPMap, CNTMap, TWidMap, W1Map, W2Map, W3Map, Tsq,stats] = ewma5(X, lambda , L, type,tt,doplot);% [SMap, SMapTh, CPMap, CNTMap, TWidMap, W1Map, W2Map, W3Map, Tsq,stats] =% ewma3(X, lambda , L, type);% EWMA - Exponentially Weighted Moving Average for fMRI slice%% Martin Lindquist % Created 09/16/05% Updated 10/01/05%%% INPUTS %% X - Data over one slice (N x N x T data matrix) or (N x T) data matrix% lambda - smoothing factor% L - width of control limits, in standard errors% type - Type of noise model - White Noise: 'WN', AR(1): 'AR', AR+WN:% 'ARMA'%% OUTPUTS%% SMap - Significance Map% SMap - Significance Map Thresholded at L standard errors% CPMap - Changepoint Map% CNTMap - Map that depicts the number of times the process is% out-of-control% TWidMap - map of total number of points out-of-control (all runs)% W1Map - map of number of points out-of-control in first run% W2Map - map of number of points out-of-control in second run% W3Map - map of number of points out-of-control in third run% Tsq - Squared, normalized data set for multi-subject analysis%% stats.model = noise type% stats.lam = value of lambda% stats.Z = EWMA statistic (smoothed timeseries) % stats.var = variance of EWMA statistic% stats.doasym = 1 for asymptotic variance 0 otherwise% stats.dim = data dimension % stats.Z3 = EWMA statistic on the format NxVxT% stats.UCL = upper control limit (at L standard errors, depends on lambda)  % stats.LCL = lower control limit%%to plot voxel i,j from a slice% i=8;j=17;ts=squeeze(fsl(i,j,:));tor_fig;plot(ts);hold on;plot(squeeze(stats.Z(i,j,:)),'r'); plot(squeeze(stats.UCL(i,j,:)),'r:');plot(squeeze(stats.LCL(i,j,:)),'r:');% plot([chptmap(i,j)],stats.Z(i,j,chptmap(i,j)),'yo','MarkerFaceColor','r')% -----------------------------------------------------------------------% Set up inputs% -----------------------------------------------------------------------    % variable inputsif ~(exist('type')==1) || isempty(type), type = 'AR(2)';, endif ~(exist('L')==1) || isempty(L), L = 3;, endif ~(exist('lambda')==1) || isempty(lambda), lambda = .2;, endif ~(exist('tt')==1) || isempty(tt), tt = 60;, endif ~(exist('doplot')==1) || isempty(doplot), doplot = 1;, end% Read-off dimensions of input datadim = size(X);if (length(dim) == 3),    N = dim(1);    V = dim(2);    T = dim(3);    M = prod(dim(1:2));elseif (length(dim) == 2),    N = dim(1);    V = 1;    T = dim(2);    M=N;else,    error('Wrong Dimensions')end;XX = reshape(X,M,T);Z = zeros(M,T);ZIU = zeros(M,T);ZIL = zeros(M,T);%tt = 60;                                     % Length of baseline time prior to potential activationdoasym = 1;                                   % if doasym = 1 use asymptotic bounds.stats.model = type;% -----------------------------------------------------------------------% Estimate variance    % Four noise cases: White noise, AR(1), AR(2) and ARMA(1,1)switch type        % -----------------------------------------------------------------------    % White noise    % -----------------------------------------------------------------------    case 'WN'    fprintf(1,'White noise.');        mu = mean(XX(:,1:tt),2);            % Calculate in-control process mean	sigma = std(XX')';      % Calculate process standard deviation               if (doasym == 1),           varZ = sigma.^2*(lambda/(1-lambda))*sqrt(1-(1-lambda).^(2*(1:T)));         else,        varZ = sigma.^2*(lambda/(1-lambda));         end;        CL = L*sqrt(varZ);               % Calculate control limits		Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic (smoothed timeseries)	ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit     stats.sigma = sigma;    % -----------------------------------------------------------------------    % AR(1)    % -----------------------------------------------------------------------       case 'AR(1)'    fprintf(1,'AR(1).');    	Phi = zeros(M,1);	sigma = zeros(M,1);	CL = zeros(M,T);    varZ = zeros(M,T);	mu = mean(XX(:,1:tt),2);     	for h=1:(M),                [a,e] = aryule((XX(h,1:tt)-mu(h)),1);       % Estimate noise parameters using Yule-Walker Estimation        Phi(h) = -a(2);        sigma(h) = sqrt(e);        % Calculate Control Limits        phi = -a(2);        s = sigma(h);        gamma0 = s^2*(1/(1 - phi^2));        gamma1 = s^2*(phi/(1 - phi^2));        if (doasym == 1),                        pt1 = lambda/(2-lambda);            pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda));            pt3 = 0;                    else,            pt1 = (lambda/(2-lambda))*(1-(1-lambda).^(2*(1:T)));            pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda))*(1-(1-lambda).^(2*(1:T)-2));            pt3 = ((2*lambda^2)/(phi-(1-lambda)))*(1/(1-phi*(1-lambda))).*((phi*(1-lambda)).^(1:T)).*(1-((1-lambda)/phi).^((1:T)-1));                        if (abs(phi) < 0.05), pt3 = zeros(size(pt3)); end;        end;                varZ(h,:) = (gamma0*pt1 + gamma1*pt2 - gamma1*pt3);                      CL(h,:) = L*sqrt((gamma0*pt1 + gamma1*pt2 - gamma1*pt3));               % Calculate control limits	end;    Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic	ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit     stats.phi = Phi;    stats.sigma = sigma;     % -----------------------------------------------------------------------    % ARMA    % -----------------------------------------------------------------------    case 'ARMA'    fprintf(1,'ARMA(1,1).');	Phi = zeros(M,1);    Theta  = zeros(M,1);	sigma = zeros(M,1);	CL = zeros(M,T);	varZ = zeros(M,T);    mu = mean(XX(:,1:tt),2); 	for h=1:(M),                m=armax(XX(h,1:tt)',[1 1]);                  % Estimate noise parameters        Phi(h) = -m.A(2);        Theta(h) = m.C(2);                sigma(h) = sqrt(m.NoiseVariance);        % Calculate Control Limits                phi = Phi(h);        theta = Theta(h);        s = sigma(h);        gamma0 = s^2*(1+ (theta + phi)^2/(1 - phi^2));        gamma1 = s^2*(theta + phi + phi*(theta + phi)^2/(1 - phi^2));        if (doasym == 1),            pt1 = (1-(1-lambda).^(2*(1:T)))/(lambda*(2-lambda));            pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda));            pt3 = 0;                    else,               pt1 = (1-(1-lambda).^(2*(1:T)))/(lambda*(2-lambda));            pt2 = (2*lambda/(2-lambda))*(1-lambda)/(1-phi*(1-lambda))*(1-(1-lambda).^(2*(1:T)-2));            pt3 = ((2*lambda^2)/(phi-(1-lambda)))*(1/(1-phi*(1-lambda))).*((phi*(1-lambda)).^(1:T)).*(1-((1-lambda)/phi).^((1:T)-1));            if (abs(phi) < 0.05), pt3 = zeros(size(pt3)); end;                end;                varZ(h,:) = abs((gamma0*pt1 + gamma1*pt2 - gamma1*pt3));              CL(h,:) = L*sqrt((gamma0*pt1 + gamma1*pt2 - gamma1*pt3));               % Calculate control limits	end;    Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic    ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit     stats.phi = Phi;    stats.theta = Theta;    stats.sigma = sigma;     % -----------------------------------------------------------------------    % AR2    % -----------------------------------------------------------------------       case 'AR(2)',            fprintf(1,'AR(2).');	Phi1 = zeros(M,1);    Phi2 = zeros(M,1);    sigma = zeros(M,1);	CL = zeros(M,T);    varZ = zeros(M,T);    mu = mean(XX(:,1:tt),2); 	% find non-empty timecourses    wh = all(XX' - repmat(mean(XX'),size(XX,2),1) <= eps) | any(isnan(XX),2)';    wh = find(~wh);    if isempty(wh), disp('Note: Empty slice.'),end    	for h=wh        [a,e] = aryule((XX(h,1:tt)-mu(h)),2);       % Estimate noise parameters using Yule-Walker Estimation        Phi1(h) = -a(2);                Phi2(h) = -a(3);        sigma(h) = sqrt(e);        % Calculate Control Limits        s = sigma(h);        w = roots(a(3:-1:1));        C = ((w(1)*w(2))^2)/((w(1)*w(2)-1)*(w(2)-w(1)));        A1 = C*(w(1)/(w(1)^2-1));        A2 = -C*(w(2)/(w(2)^2-1));        gamma0 = A1 + A2;                if (doasym == 1),                       pt1 = gamma0*lambda/(2-lambda);            pt2 = 2*lambda^2*A1*w(1)/(w(1)-(1-lambda))*((1-lambda)/(w(1)*lambda*(2-lambda)));                       pt3 = 2*lambda^2*A2*w(2)/(w(2)-(1-lambda))*((1-lambda)/(w(2)*lambda*(2-lambda)));        else,                        pt1 = gamma0*lambda*(1-(1-lambda).^(2*(1:T)))/(2-lambda);            pt2 = 2*lambda^2*A1*w(1)/(w(1)-(1-lambda))*((1-lambda)/(w(1)*lambda*(2-lambda))*(1-(1-lambda).^(2*(1:T)-2))-(((1-lambda)/w(1)).^(1:T)).*((1-(1-lambda)*w(1)).^((1:T)-1))/(1-(1-lambda)*w(1)));                pt3 = 2*lambda^2*A2*w(2)/(w(2)-(1-lambda))*((1-lambda)/(w(2)*lambda*(2-lambda))*(1-(1-lambda).^(2*(1:T)-2))-(((1-lambda)/w(2)).^(1:T)).*(1-((1-lambda)*w(2)).^((1:T)-1))/(1-(1-lambda)*w(2)));        end;           varZ(h,:) = s.^2.*abs(pt1 + pt2 + pt3);               % Calculate control limits        CL(h,:) = L*s*real(sqrt(pt1 + pt2 + pt3));               % Calculate control limits	end;    Z(:,1) = mu;	for i=2:T, Z(:,i) = lambda*XX(:,i) + (1-lambda)*Z(:,(i-1)); end;        % Calculate EWMA statistic	ZIU(Z-(mu*(1+zeros(1,T))) > CL) = 1;          % 0-1 Matrix of points above upper control limit  	ZIL(Z-(mu*(1+zeros(1,T))) < -CL) = 1;         % 0-1 Matrix of points below lower control limit         stats.phi1 = Phi1;    stats.phi2 = Phi2;    stats.sigma = sigma;            otherwise        error('Unknown error model type.')end% End variance estimation% ----------------------------------------------------------------------- % -----------------------------------------------------------------------% Estimate change points% -----------------------------------------------------------------------% Estimation via Zero-crossings[CP2,CNTmat,TOTmat,LENmat] = zero_crossing(M,T,XX,ZIU,ZIL,Z,mu);% -----------------------------------------------------------------------% Define output maps% -----------------------------------------------------------------------warning offSMap = reshape(max(((Z- repmat(mu,1,T))./sqrt(varZ))')',N,V);            % Significance MapSMapTh = zeros(size(SMap));SMapTh(find(SMap>L)) = 1;                                           % Significance Map - ThresholdedCPMap = reshape(CP2,N,V);                                           % Changepoint MapCNTMap = reshape(CNTmat,N,V);                                       % Map that depicts the number of times the process is out-of-controlTWidMap = reshape(TOTmat,N,V);                                      % TWidMap - map of total number of points out-of-control (all runs)W1Map = reshape(LENmat(:,1),N,V);                                   % W1Map - map of number of points out-of-control in first runW2Map = reshape(LENmat(:,2),N,V);                                   % W2Map - map of number of points out-of-control in second runW3Map = reshape(LENmat(:,3),N,V);                                   % W3Map - map of number of points out-of-control in third runstats.lam = lambda;stats.Z = Z;stats.var = varZ;stats.doasym = doasym;stats.dim = [N, V, T];stats.Z3 = reshape(Z,N,V,T); UCL = mu*(1+zeros(1,T)) + CL;LCL = mu*(1+zeros(1,T)) - CL;stats.UCL = reshape(UCL,N,V,T);  stats.LCL = reshape(LCL,N,V,T);Tsq = (Z.^2)/((CL(end)/L)^2);                                       % Tsq - Squared, normalized data set for multi-subject analysis% -----------------------------------------------------------------------% Plot maps% -----------------------------------------------------------------------%doplot = 1;if doplot     if M == 1        % one timecourse                % needed for timecourse ewma plot        stats.mu = mu;        stats.cp = CP2;        [cp,tm,b,t,wh,oocvec] = change_point(((stats.Z-mu)./(stats.var.^.5)),tt,'thresh',L);                % q is vector of null hyp t-values from Monte Carlo        [Zcor,p,tthresh,q,C] = timeseries_mc_pvalue(stats.var(:,tt+1:end),lambda,1,stats.var(:,tt+1:end),1,max(t));   % Only use data after baseline ends to calculate p-value        hewma2_plot(stats.Z,mu,cp,[],wh,find(t == max(t)),L,tt,tm,q,1,stats.Z,sqrt(stats.var))                    else                subplot(2,4,1)        imagesc(SMap); colorbar('horiz');        subplot(2,4,2)        imagesc(SMapTh); colorbar('horiz');        subplot(2,4,3)        imagesc(CPMap);colorbar('horiz');        subplot(2,4,4)        imagesc(CNTMap);colorbar('horiz');        subplot(2,4,5)        imagesc(TWidMap);colorbar('horiz');        subplot(2,4,6)        imagesc(W1Map);colorbar('horiz');        subplot(2,4,7)        imagesc(W2Map);colorbar('horiz');        subplot(2,4,8)        imagesc(W3Map);colorbar('horiz');    enddrawnowendreturn;